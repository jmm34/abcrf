{
    "collab_server" : "",
    "contents" : "---\ntitle: \"\"\nauthor: \"Arnaud Guillin, Jean-Michel Marin, Pierre Pudlo and Christian Robert\"\ndate: \"July 2017\"\noutput: \n  pdf_document:\n    citation_package: natbib\nfontsize: 10pt\nbiblio-style: \"apalike\"\ntoc: true\nnumbersections: true\nheader-includes:\n   - \\usepackage[francais]{babel}\nbibliography: GMPR17.bib\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n```{r library, include=FALSE}\nlibrary(mvtnorm)\nlibrary(abcrf)\n```\n\n# The model\n\nWe consider the following regression model. We have a $n$-sample $(x_i,y_i)$ such that\n$$\nx_i\\sim\\mathcal{N}_d(0_3,\\Sigma_x)\n$$\nwhere\n$$\n\\Sigma_x=0.5J_3+0.5I_3\n$$\n$$\ny_i\\sim\\mathcal{N}_1(x_i^T\\theta,1)\n$$\nThe prior distribution on the parameter $\\theta=(\\theta_1,\\theta_2,\\theta_3)$\n$$\n(\\theta_1,\\theta_2,\\theta_3)\\sim\\mathcal{N}_3(0_3,n(X^TX)^{-1})\n$$\n\nWe set $n=100$ and generate \n```{r data-gen, include=FALSE, cache=TRUE}\nd <- 3\nn <- 100\nSigma <- matrix(0.5,d,d)\ndiag(Sigma) <- rep(1,d)\nlibrary(mvtnorm)\nX <- rmvnorm(n,rep(0,d),Sigma)\ntheta <- rep(1,d)\ny <- as.vector(rmvnorm(1,X%*%theta,diag(n)))\nthetahat <- solve(t(X)%*%X)%*%t(X)%*%y\n```\n\n# Estimation of the full conditional distributions using RF\n\nWe first generate a reference table including 50,000 simulations\nfrom the prior predictive model. The R object \\verb+app+ contains this table, \nas summary statistics we use the maximum likelihood estimators.\n\n```{r rf, include=FALSE, cache=TRUE}\nnsim <- 10000\nthetasim <- matrix(0,nsim,d)\nysim <- matrix(0,nsim,n)\nXXm <- solve(t(X)%*%X)\n\nthetasim <- rmvnorm(nsim,rep(0,d),n*XXm)\nysim <- t(X%*%t(thetasim))+rmvnorm(nsim,rep(0,n),diag(n))\n\nlulu <- XXm%*%t(X)%*%t(ysim)\napp <- data.frame(cbind(thetasim,t(lulu)))\nnames(app) <- c(\"theta1\",\"theta2\",\"theta3\",\"s1\",\"s2\",\"s3\")\n```\n\nThen, using quantile regression forests, we estimate the full conditional\ndistributions the components of $\\theta$.\n\n```{r fullcond, include=FALSE, cache=TRUE}\nmodel1.marg <- regAbcrf(theta1~s1+s2+s3,data=app,ntree=5000,paral=TRUE)\nprep1.marg <- prep(model1.marg,app,8)\nwei1.marg <- wei(model1.marg,prep1,data.frame(s1=thetahat[1],s2=thetahat[2],s3=thetahat[3]),8)\n\nmodel1 <- regAbcrf(theta1~.,data=app,ntree=1000,paral=TRUE)\nmodel2 <- regAbcrf(theta2~.,data=app,ntree=1000,paral=TRUE)\nmodel3 <- regAbcrf(theta3~.,data=app,ntree=1000,paral=TRUE)\n```\n\n# Approximate Gibbs sampling \n\n```{r gibbsapprox, include=FALSE, cache=TRUE}\nprep <- function(object,training,ncores)\n{\n    ntrees <-  object$model.rf$num.trees\n    mf <- match.call(expand.dots = FALSE)\n    mf <- mf[1]\n    mf$formula <- object$formula\n    mf$data <- training\n    mf[[1L]] <- as.name(\"model.frame\")\n    mf <- eval(mf, parent.frame())\n    mt <- attr(mf, \"terms\")\n    obj <- object$model.rf\n    inbag <- matrix(unlist(obj$inbag.counts, use.names = FALSE), ncol = ntrees, byrow = FALSE)\n    obj[[\"origNodes\"]] <- predict(object$model.rf, training, predict.all = TRUE, num.threads = ncores)$predictions\n    obj[[\"origObs\"]] <- model.response(mf)\n    origObs <- obj$origObs\n    origNodes <- obj$origNodes\n\tlist(ori=origNodes,inbag=inbag)\n}\n\nwei <- function(object,prepa,obs,ncores)\n{\n\tntrees <-  object$model.rf$num.trees\n\tnapp <- object$model.rf$num.samples\n  nodes <- predict(object$model.rf, obs, predict.all = TRUE, num.threads = ncores)$predictions\n    weights <- abcrf:::findweights(prepa$ori,prepa$inbag, nodes, napp, 1, ntrees)\n    weights/ntrees\n}\n\nprep1 <- prep(model1,app,8)\nprep2 <- prep(model2,app,8)\nprep3 <- prep(model3,app,8)\n\nT  <- 1000\nx <- matrix(0,T,3)\n\nfor (t in 2:T)\n{\nwei1 <- wei(model1,prep1,data.frame(theta2=x[t-1,2],theta3=x[t-1,3],\n                                    s1=thetahat[1],s2=thetahat[2],s3=thetahat[3]),8)\nx[t,1] <- sample(app$theta1,1,prob=wei1)\nwei2 <- wei(model2,prep2,data.frame(theta1=x[t,1],theta3=x[t-1,3],\n                                    s1=thetahat[1],s2=thetahat[2],s3=thetahat[3]),8)\nx[t,2] <- sample(app$theta2,1,prob=wei2)\nwei3 <- wei(model3,prep3,data.frame(theta1=x[t,1],theta2=x[t,2],\n                                    s1=thetahat[1],s2=thetahat[2],s3=thetahat[3]),8)\nx[t,3] <- sample(app$theta3,1,prob=wei3)\nprint(t)\n}\n```\n\n\n```{r graph1, echo=FALSE, cache=TRUE, fig.pos='h!', fig.height=2.2, fig.width=7, fig.align='center', fig.cap='Comparison of estimates'}\nplot(acf(x[,1]))\nplot(ecdf(x[,1]))\ncurve(pnorm(x,n/(n+1)*thetahat[1],sqrt(n/(n+1)*XXm[1,1])),add=TRUE,col=\"red\")\n```\n\n# Another strategy\n\nRussian doll decomposition:\n\\begin{itemize}\n\\item[1.] we estimate the marginal posterior  of $\\theta_1$, that is the condiotional\ndistribution of $\\theta_1$ givne $\\hat\\theta$\n\\item[2.] the distribution of $\\theta_2$ given $\\theta_1,\\hat\\theta$\n\\item[3.] the full conditional distribution of $\\theta_3$, that is\nthe distribution of $\\theta_3$ given $\\theta_1,\\theta_2,\\hat\\theta$\n\\end{itemize}\nThis methodology depends on the order of the decomposition.\n\n```{r russian-doll, include=FALSE, cache=TRUE}\nmodel1.bis <- quantregForest(x=app[,-(1:d)],y=app[,1],ntree=1000,nthreads=8)\nmodel2.bis <- quantregForest(x=app[,-(2:d)],y=app[,2],ntree=800,nthread=8)\nmodel3.bis <- model3\n```\n\n```{r orderapprox, include=FALSE, cache=TRUE}\nN <- 1000\nlala1 <- as.vector(predict(model1, t(thetahat),what=runif(N)))\nlala2 <- lala3 <- rep(0,N)\nguillin <- cbind(matrix(rep(thetahat,N),N,byrow=TRUE),lala1)\nfor (i in 1:N) lala2[i] <- as.vector(predict(model2, guillin[i,],what=runif(1)))\nguillin <- cbind(matrix(rep(thetahat,N),N,byrow=TRUE),lala1,lala2)\nfor (i in 1:N) lala3[i] <- as.vector(predict(model3, guillin[i,],what=runif(1)))\n```\n\n\n",
    "created" : 1500968887419.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1180603771",
    "id" : "AC5EB8D4",
    "lastKnownWriteTime" : 1501070795,
    "last_content_update" : 1501073318443,
    "path" : "~/Dropbox/RANTANPLAN/GMPR17.Rmd",
    "project_path" : null,
    "properties" : {
        "last_setup_crc32" : "B315DEABbb338d19"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}