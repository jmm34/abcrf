{
    "collab_server" : "",
    "contents" : "covRegAbcrf.regAbcrf <-\nfunction(regForest1, regForest2, newdata, ntree=500, sampsize=min(1e5, nrow(regForest1$sumsta)), paral=FALSE, ... ){\n  \n  if (!inherits(regForest1, \"regAbcrf\")) \n    stop(\"regForest1 not of class regAbcrf\")\n  if (!inherits(regForest2, \"regAbcrf\")) \n    stop(\"regForest2 not of class regAbcrf\")\n\n  if(any(dim(regForest1$sumsta) != dim(regForest2$sumsta) ))\n    stop(\"regForest1 and regForest2 training data are not constructed on the same summaries\")\n  if(any(regForest1$sumsta != regForest2$sumsta) )\n    stop(\"regForest1 and regForest2 training data are not constructed on the same summaries\")\n  \n  train.data <- regForest1$sumsta\n  object1 <- regForest1$model.rf\n  object2 <- regForest2$model.rf\n  x <- newdata\n  \n  if(!is.null(x)){\n    if(is.vector(x)){\n      x <- matrix(x,ncol=1)\n    }\n    if (nrow(x) == 0) \n      stop(\"newdata has 0 rows\")\n    if (any(is.na(x))) \n      stop(\"missing values in newdata\")\n  }\n  \n  if(!is.null(x)){\n    vname <- if (is.null(dim(object2$importance))) {\n      names(object2$importance)\n    } else {\n      rownames(object2$importance)\n    }\n    \n    if (any(colnames(x) != vname))\n      stop(\"names of predictor variables do not match\")\n  }\n  \n  \n  # residuals\n  \n  res1 <- regForest1$model.rf$y - predict(regForest1$model.rf)\n  res2 <- regForest2$model.rf$y - predict(regForest2$model.rf)\n  \n  res12 <- res1*res2 # new response varible\n  \n  # forest construction\n  \n  if (paral==TRUE) {\n    ncores <- max(detectCores()-1,1) \n    cl <- makeCluster(ncores)\n    registerDoParallel(cl)\n    if (trunc(ntree/ncores)==ntree/ncores) ntrees <- rep(ntree/ncores, ncores) else\n      ntrees <- c(rep(trunc(ntree/ncores), ncores),ntree-trunc(ntree/ncores)*ncores)\n    model.rf <- foreach(ntree=ntrees, .combine= combine, .multicombine=TRUE, .packages='randomForest') %dorng% {\n      randomForest(regForest1$sumsta, res12, ntree=ntree, sampsize=sampsize, keep.inbag=TRUE, ...)\n    }\n    stopCluster(cl)\n    pred.noob <- predict(model.rf, newdata=regForest1$sumsta, predict.all=TRUE)\n    mat <- pred.noob$individual\n    for( j in 1:model.rf$ntree ){\n      mat[model.rf$inbag[,j]!=0,j] <- NA\n    }\n    model.rf$predicted <- sapply(1:nrow(regForest1$sumsta), function(x) mean(mat[x,!is.na(mat[x,])]) )\n  } else model.rf <- randomForest(regForest1$sumsta, res12, ntree=ntree, sampsize=sampsize, keep.inbag = TRUE, ...)\n  \n  result <- predict(model.rf, newdata=x)\n  \n  return(result)\n  \n}\n\n\ncovRegAbcrf <-\nfunction(...) UseMethod(\"covRegAbcrf\")\n",
    "created" : 1464980765982.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "337517951",
    "id" : "EB67D53D",
    "lastKnownWriteTime" : 1464183528,
    "last_content_update" : 1464183528,
    "path" : "~/Dropbox/ODOF/abcrf/R/covRegAbcrf.R",
    "project_path" : "R/covRegAbcrf.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}