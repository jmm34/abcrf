{
    "collab_server" : "",
    "contents" : "predict.regAbcrf <-\nfunction(object, newdata, quantiles=c(0.025,0.975) , ...){\n\n  train.data <- object$sumsta\n  obj <- object$model.rf\n  inbag <- obj$inbag\n  x <- newdata\n\n  class(obj) <- c(\"quantregForest\", \"randomForest\")\n  obj[[\"origNodes\"]] <- predict(object$model.rf, train.data, predict.all=TRUE)$individual\n  obj[[\"origObs\"]] <- object$model.rf$y\n  obj[[\"importance\"]] <- object$model.rf$importance[,-1]\n  obj[[\"quantiles\"]] <- NULL\n\n  ### Checking arguments\n  if (!inherits(object, \"regAbcrf\"))\n    stop(\"object not of class regAbcrf\")\n  if(min(quantiles)<0 | max(quantiles)>1 )\n    stop(\"quantiles must be in [0,1]\")\n\n  x <- newdata\n  if(!is.null(x)){\n    if(is.vector(x)){\n      x <- matrix(x,ncol=1)\n    }\n    if (nrow(x) == 0)\n      stop(\"newdata has 0 rows\")\n    if (any(is.na(x)))\n      stop(\"missing values in newdata\")\n  }\n\n  ### prediction\n\n  origObs <- obj$origObs\n  origNodes <- obj$origNodes\n\n  quant <- matrix(nrow=nrow(x),ncol=length(quantiles))\n  mediane <- matrix(nrow=nrow(x), ncol=1)\n  nodes <- predict(object$model.rf, x, predict.all=TRUE)$individual\n  ntree <- obj$ntree\n\n  nobs <- length(origObs)\n  nnew <- nrow(x)\n  normalise <- 1\n  weightvec <- rep(0,nobs*nnew)\n  counti <- rep(0,nobs)\n  thres <- 5*.Machine$double.eps\n  result <- .C(\"findweightsAmelioree\",\n               as.double(as.vector(origNodes)),\n               as.integer(as.vector(inbag)),\n               as.double(as.vector(nodes)),\n               weightvec=as.double(weightvec),\n               as.integer(nobs),\n               as.integer(nnew),\n               as.integer(ntree),\n               as.double(thres),\n               as.integer(counti),\n               as.integer(normalise),\n               PACKAGE=\"abcrf\")\n\n  weights <- matrix(result$weightvec,nrow= nobs)\n  weights.std <- sapply(1:nrow(x),function(x) weights[,x]/sum(weights[,x])) # weights std\n\n  # esper <- sapply(1:nrow(x), function(x) weights.std[,x]%*%origObs)\n  esperRf <- predict(object$model.rf, newdata=x, ...)\n\n  # Out of bag expectations\n\n  predict.oob <- predict(object$model.rf)\n\n  # squared residuals\n\n  residus.oob.sq <- (origObs - predict.oob)^2\n\n  # variance estimation\n\n  variance <- sapply(1:nrow(x), function(x) weights.std[,x] %*% residus.oob.sq)\n\n  # Quantiles calculation\n\n  ord <- order(origObs)\n  origObs <- origObs[ord]\n  weights <- weights[ord,,drop=FALSE]\n  cumweights <- apply(weights,2,cumsum)\n  cumweights <- sweep(cumweights,2,as.numeric(cumweights[nobs,]),FUN=\"/\")\n\n  # quantiles (code Meins)\n\n  for (qc in 1:length(quantiles)){\n    larg <- cumweights<quantiles[qc]\n    wc <- apply(larg,2,sum)+1\n    ind1 <- which(wc<1.1)\n    indn1 <- which(wc>1.1)\n    quant[ind1,qc] <- rep(origObs[1],length(ind1))\n    quantmax <- origObs[wc[indn1]]\n    quantmin <- origObs[wc[indn1]-1]\n    weightmax <- cumweights[cbind(wc[indn1],indn1)]\n    weightmin <- cumweights[cbind(wc[indn1]-1,indn1)]\n    factor <- numeric(length(indn1))\n    indz <- weightmax-weightmin<10^(-10)\n    factor[indz] <- 0.5\n    factor[!indz] <- (quantiles[qc]-weightmin[!indz])/(weightmax[!indz]-weightmin[!indz])\n    quant[indn1,qc] <- quantmin + factor* (quantmax-quantmin)\n  }\n\n  colnames(quant) <- paste(\"quantile=\",quantiles)\n\n  # mediane estimation\n\n  larg <- cumweights< 0.5\n  wc <- apply(larg,2,sum)+1\n  ind1 <- which(wc<1.1)\n  indn1 <- which(wc>1.1)\n  mediane[ind1,1] <- rep(origObs[1],length(ind1))\n  quantmax <- origObs[wc[indn1]]\n  quantmin <- origObs[wc[indn1]-1]\n  weightmax <- cumweights[cbind(wc[indn1],indn1)]\n  weightmin <- cumweights[cbind(wc[indn1]-1,indn1)]\n  factor <- numeric(length(indn1))\n  indz <- weightmax-weightmin<10^(-10)\n  factor[indz] <- 0.5\n  factor[!indz] <- (0.5-weightmin[!indz])/(weightmax[!indz]-weightmin[!indz])\n  mediane[indn1,1] <- quantmin + factor* (quantmax-quantmin)\n\n  tmp <- list(expectation = esperRf, med = mediane, variance = variance, quantiles = quant)\n  class(tmp) <- \"regAbcrfpredict\"\n  tmp\n\n}\n\n\nprint.regAbcrfpredict <-\nfunction(x, ...){\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  print(ret, ...)\n\n}\n\nas.data.frame.regAbcrfpredict <-\nfunction(x, ...) {\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  as.data.frame(ret,  row.names=NULL, optional=FALSE, ...)\n\n}\n\nas.matrix.regAbcrfpredict <-\nfunction(x, ...){\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  ret\n\n}\n\nas.list.regAbcrfpredict <-\nfunction(x, ...){\n\n    list(expectation = x$expectation, med = x$med , variance = x$variance, quantiles=x$quantiles, ...)\n\n}\n",
    "created" : 1464980687841.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2685471433",
    "id" : "E49906F7",
    "lastKnownWriteTime" : 1464980750,
    "last_content_update" : 1464980750562,
    "path" : "~/Dropbox/ODOF/abcrf/R/predict.regAbcrf.R",
    "project_path" : "R/predict.regAbcrf.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}