{
    "collab_server" : "",
    "contents" : "covRegAbcrf.regAbcrf <-\nfunction(regForest1, regForest2, obs, training1, training2, ntree=500, mtry=max(floor((dim(training1)[2]-1)/3), 1), sampsize=min(1e5, dim(training1)[1]), \n         paral = FALSE, ncores = if(paral) max(detectCores()-1,1) else 1,\n         paral.predict = FALSE, ncores.predict = if(paral.predict) max(detectCores()-1,1) else 1, ... ){\n  \n  if (!inherits(obs, \"data.frame\")) \n    stop(\"obs needs to be a data.frame object\")\n  if (!inherits(regForest1, \"regAbcrf\")) \n    stop(\"regForest1 not of class regAbcrf\")\n  if (!inherits(regForest2, \"regAbcrf\")) \n    stop(\"regForest2 not of class regAbcrf\")\n  if (!inherits(training1, \"data.frame\"))\n    stop(\"training1 needs to be a data.frame object\")\n  if (!inherits(training2, \"data.frame\"))\n    stop(\"training2 needs to be a data.frame object\")\n  if(any(regForest1$model.rf$forest$independent.variable.names != regForest1$model.rf$forest$independent.variable.names) )\n    stop(\"variable names of the regAbcrf objects do not match\")\n  \n  if(regForest1$formula != regForest1$formula )\n    stop(\"regForest1 and regForest2 formulas do not match\")\n\n  if(sampsize > nrow(training1) )\n    stop(\"sampsize too large\")\n  \n  if ( (!is.logical(paral)) && (length(paral) != 1L) )\n    stop(\"paral should be TRUE or FALSE\")\n  if ( (!is.logical(paral.predict)) && (length(paral.predict) != 1L) )\n    stop(\"paral.predict should be TRUE or FALSE\")\n  if( (ncores > detectCores() || ncores < 1) || (ncores.predict > detectCores() || ncores.predict < 1) )\n    stop(\"incorrect number of CPU cores\")\n  \n  x <- obs\n  \n  if(!is.null(x)){\n    if(is.vector(x)){\n      x <- matrix(x,ncol=1)\n    }\n    if (nrow(x) == 0) \n      stop(\"obs has 0 rows\")\n    if (any(is.na(x))) \n      stop(\"missing values in obs\")\n  }\n  \n  if(!is.null(x)){\n    if (any(colnames(x) != regForest1$model.rf$forest$independent.variable.names))\n      stop(\"names of predictor variables do not match\")\n  }\n  \n  # recover response\n  \n  mf1 <- match.call(expand.dots=FALSE)\n  mf1 <- mf1[1]\n  mf1$formula <- regForest1$formula\n  mf1$data <- training1\n  mf1[[1L]] <- as.name(\"model.frame\")\n  mf1 <- eval(mf1, parent.frame() )\n  mt1 <- attr(mf1, \"terms\")\n  resp1 <- model.response(mf1)\n  \n  sumsta1 <- training1[regForest1$model.rf$forest$independent.variable.names]\n  \n  mf2 <- match.call(expand.dots=FALSE)\n  mf2 <- mf2[1]\n  mf2$formula <- regForest2$formula\n  mf2$data <- training2\n  mf2[[1L]] <- as.name(\"model.frame\")\n  mf2 <- eval(mf2, parent.frame() )\n  mt2 <- attr(mf2, \"terms\")\n  resp2 <- model.response(mf2)\n  \n  sumsta2 <- training2[regForest2$model.rf$forest$independent.variable.names]\n   \n  if(any(dim(sumsta1) != dim(sumsta2) ))\n    stop(\"regForest1 and regForest2 training data are not build on the same summaries\")\n  if(any(sumsta1 != sumsta2) )\n    stop(\"regForest1 and regForest2 training data are not build on the same summaries\")\n  \n  \n  # residuals\n  \n  res1 <- resp1 - regForest1$model.rf$predictions\n  res2 <- resp2 - regForest2$model.rf$predictions\n  \n  res12 <- res1*res2 # new response variable\n  \n  # construction du dataframe pour ranger\n  data.ranger <- data.frame(res12, sumsta1)\n  \n  # forest construction\n\n  m <- names(match.call(expand.dots=TRUE))\n  \n  model.rf <- ranger(res12~., data=data.ranger, num.trees = ntree, sample.fraction=sampsize/length(res12),\n                           num.threads = ncores, mtry=mtry, ...)\n  \n  result <- predict(model.rf, x, num.threads=ncores.predict)$predictions\n  \n  return(result)\n  \n}\n\n\ncovRegAbcrf <-\nfunction(...) UseMethod(\"covRegAbcrf\")\n",
    "created" : 1479998077494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2754839147",
    "id" : "C21747CA",
    "lastKnownWriteTime" : 1479904790,
    "last_content_update" : 1479904790,
    "path" : "C:/Users/Louis Raynal/Dropbox/ODOF/abcrf 1.4 avec ranger/abcrf_1.4/R/covRegAbcrf.R",
    "project_path" : "R/covRegAbcrf.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}