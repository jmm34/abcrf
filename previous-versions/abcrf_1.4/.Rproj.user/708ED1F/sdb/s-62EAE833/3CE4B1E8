{
    "collab_server" : "",
    "contents" : "predict.abcrf <- function(object, obs, training, ntree = 1000, sampsize = min(1e5,  object$model.rf$num.samples ), \n                          paral = FALSE, ncores = if(paral) max(detectCores()-1,1) else 1,\n                          paral.predict = FALSE, ncores.predict = if(paral.predict) max(detectCores()-1,1) else 1 , ...)\n{\n  if (!inherits(obs, \"data.frame\")) \n    stop(\"obs needs to be a data.frame object\")\n  if (!inherits(training, \"data.frame\"))\n    stop(\"training needs to be a data.frame object\")\n  if (nrow(obs) == 0L || is.null(nrow(obs)))\n    stop(\"no data in obs\")\n  if (nrow(training) == 0L || is.null(nrow(training)))\n    stop(\"no simulation in the training reference table (response, sumstat)\")\n  if ( (!is.logical(paral)) && (length(paral) != 1L) )\n    stop(\"paral should be TRUE or FALSE\")\n  if ( (!is.logical(paral.predict)) && (length(paral.predict) != 1L) )\n    stop(\"paral.predict should be TRUE or FALSE\")\n  if( (ncores > detectCores() || ncores < 1) || (ncores.predict > detectCores() || ncores.predict < 1) )\n    stop(\"incorrect number of CPU cores\")\n  \n  nmod <- length(object$model.rf$forest$levels)\n  ntrain <- object$model.rf$num.samples\n  nstat <- object$model.rf$num.independent.variables\n  \n  # modindex and sumsta recovery\n  \n  mf <- match.call(expand.dots=FALSE)\n  mf <- mf[1]\n  mf$formula <- object$formula\n  mf$data <- training\n  mf[[1L]] <- as.name(\"model.frame\")\n  mf <- eval(mf, parent.frame() )\n  mt <- attr(mf, \"terms\")\n  modindex <- model.response(mf)\n  sumsta <- model.frame(terms(reformulate(attributes(mt)$term.labels)), data.frame(mf))\n  \n  nobs <- nrow(obs)\n\n\tif (is.null(colnames(obs))) {\n\t  colnames(obs) <- object$model.rf$forest$independent.variable.names[1:(nstat-nmod-1)]\n    warning(\"Columns of obs have no names\")\n\t}\n  if(sampsize > ntrain)\n    stop(\"sampsize too large\")\n  \n\told.options <- options(); options(warn=-1)\n\tif (object$lda) {\n\t  obs <- cbind(obs, predict(object$model.lda, obs)$x)\n\t\tsumsta <- cbind( sumsta, predict(object$model.lda, training)$x )\n\t}\n\t\n\tallocation <- predict(object$model.rf, obs, num.threads=ncores.predict)$predictions\n\t\n\t# vote :\n\t\n\tvote <- matrix( nrow=nobs, ncol=nmod)\n\tcolnames(vote) <- object$model.rf$forest$levels\n\t\n\tpred.all <- predict(object$model.rf, obs, predict.all=TRUE, num.threads=ncores.predict)$predictions\n\tfor(i in object$model.rf$forest$class.values ){\n\t  vote[,i] <- sapply(1:nobs, function(x) mean(pred.all[x,] == i ) )\n\t}\n\t\n\tlocal.error <- as.numeric(object$model.rf$predictions == modindex)\n\n\t\t\n\t# data.frame for ranger \n\tdata.ranger <- data.frame(local.error, sumsta )\n\t\n  error.rf <- ranger(local.error~., data=data.ranger, num.trees = ntree, \n                       sample.fraction=sampsize/ntrain, num.threads = ncores, ...)\n\n  options(old.options)\n\ttmp <- list(allocation=allocation, vote=vote, post.prob=predict(error.rf, obs, num.threads=ncores.predict)$predictions )\n  class(tmp) <- \"abcrfpredict\"\n  tmp\n}\n\nsummary.abcrfpredict <- function(object, ...) {\n  cat(\"Number of affectations per model:\\n\")\n  summary(object$allocation, ...)\n}\n\nprint.abcrfpredict <- function(x, ...) {\nret <- cbind.data.frame(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  print(ret, ...)\n}\n\nas.matrix.abcrfpredict <- function(x, ...) {\n  ret <- cbind(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  ret\n}\n\nas.data.frame.abcrfpredict <- function(x, ...) {\n  ret <- cbind(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  as.data.frame(ret,  row.names=NULL, optional=FALSE, ...)\n}\n\nas.list.abcrfpredict <- function(x, ...) {\n  list(allocation = x$allocation, vote = x$vote, post.prob = x$post.prob, ...)\n}",
    "created" : 1479998423042.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "834641513",
    "id" : "3CE4B1E8",
    "lastKnownWriteTime" : 1479749520,
    "last_content_update" : 1479749520,
    "path" : "E:/These/abcrf 1.4 avec ranger/abcrf_1.4/R/predict.abcrf.R",
    "project_path" : "R/predict.abcrf.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}