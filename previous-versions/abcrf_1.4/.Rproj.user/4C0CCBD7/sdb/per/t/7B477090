{
    "contents" : "predict.regAbcrf <- function(object, obs, training, quantiles=c(0.025,0.975),\n                             paral = FALSE, ncores = if(paral) max(detectCores()-1,1) else 1, ...)\n{\n  ### Checking arguments\n  \n  if (!inherits(obs, \"data.frame\")) \n    stop(\"obs needs to be a data.frame object\")\n  if (!inherits(training, \"data.frame\"))\n    stop(\"training needs to be a data.frame object\")\n  if (nrow(training) == 0L || is.null(nrow(training)))\n    stop(\"no simulation in the training reference table (response, sumstat)\")\n  if ( (!is.logical(paral)) && (length(paral) != 1L) )\n    stop(\"paral should be TRUE or FALSE\")\n  if( ncores > detectCores() || ncores < 1 )\n    stop(\"incorrect number of CPU cores\")\n  if(min(quantiles)<0 | max(quantiles)>1 )\n    stop(\"quantiles must be in [0,1]\")\n  \n  ntrain <- object$model.rf$num.samples\n  nstat <- object$model.rf$num.independent.variables\n  \n  # modindex and sumsta recovery\n  \n  mf <- match.call(expand.dots=FALSE)\n  mf <- mf[1]\n  mf$formula <- object$formula\n  mf$data <- training\n  mf[[1L]] <- as.name(\"model.frame\")\n  mf <- eval(mf, parent.frame() )\n  mt <- attr(mf, \"terms\")\n  resp <- model.response(mf)\n\n  sumsta <- training[object$model.rf$forest$independent.variable.names]\n  \n  obj <- object$model.rf\n  inbag <- matrix(unlist(obj$inbag.counts, use.names=FALSE), ncol=obj$num.trees, byrow=FALSE)\n\n  obj[[\"origNodes\"]] <- predict(object$model.rf, training, predict.all=TRUE, num.threads=ncores)$predictions\n  obj[[\"origObs\"]] <- resp\n  obj[[\"importance\"]] <- obj$variable.importance\n  obj[[\"quantiles\"]] <- NULL\n\n  x <- obs\n  if(!is.null(x)){\n    if(is.vector(x)){\n      x <- matrix(x,ncol=1)\n    }\n    if (nrow(x) == 0)\n      stop(\"obs has 0 rows\")\n    if (any(is.na(x)))\n      stop(\"missing values in obs\")\n  }\n\n  ### prediction\n\n  origObs <- obj$origObs\n  origNodes <- obj$origNodes\n\n  quant <- matrix(nrow=nrow(x),ncol=length(quantiles))\n  mediane <- matrix(nrow=nrow(x), ncol=1)\n  nodes <- predict(object$model.rf, x, predict.all=TRUE, num.threads=ncores)$predictions\n  if(is.null(dim(nodes))) nodes <- matrix(nodes, nrow=1)\n  ntree <- obj$num.trees\n\n  nobs <- length(origObs)\n  nnew <- nrow(x)\n  weightvec <- rep(0,nobs*nnew)\n  counti <- rep(0,nobs)\n  thres <- 5*.Machine$double.eps # basiquement, 0\n  result <- .C(\"findweightsAmelioree\",\n               as.double(as.vector(origNodes)),\n               as.integer(as.vector(inbag)),\n               as.double(as.vector(nodes)),\n               weightvec=as.double(weightvec),\n               as.integer(nobs),\n               as.integer(nnew),\n               as.integer(ntree),\n               as.double(thres),\n               as.integer(counti),\n               PACKAGE=\"abcrf\")\n\n  weights <- matrix(result$weightvec,nrow= nobs)\n  weights.std <- weights/object$model.rf$num.trees\n\n  # calcul des poids\n  \n  temp.data <- rbind(sumsta, obs)\n\n  pred.ID <- predict(object$model.rf, temp.data, type=\"terminalNodes\", num.threads=ncores)$predictions\n  \n  weight <- c()\n  weight.std <- c()\n  browser()\n  for(i in 1:nnew){\n    matYesNo <- matrix(rep(pred.ID[nobs+i,], nobs), nobs, byrow=TRUE)==pred.ID[1:nobs,]\n    matYesNo2 <- matYesNo* inbag\n    matYesNo3 <- matYesNo* (inbag!=0)\n    matYesNo <- matYesNo/rowSums(matYesNo)\n    weight <- cbind( colSums(matYesNo) , weight)\n  }\n  weight.std <- weight/object$model.rf$num.trees\n    \n  # esper <- sapply(1:nrow(x), function(x) weights.std[,x]%*%origObs)\n  esperRf <- predict(object$model.rf, data=x, ...)$predictions\n  \n  # Out of bag expectations\n\n  predict.oob <- object$model.rf$predictions\n\n  # squared residuals\n\n  residus.oob.sq <- (origObs - predict.oob)^2\n\n  # variance estimation\n\n  variance <- sapply(1:nrow(x), function(x) weights.std[,x] %*% residus.oob.sq)\n\n  # Quantiles calculation\n\n  ord <- order(origObs)\n  origObs <- origObs[ord]\n  weights <- weights[ord,,drop=FALSE]\n  cumweights <- apply(weights,2,cumsum)\n  cumweights <- sweep(cumweights,2,as.numeric(cumweights[nobs,]),FUN=\"/\")\n\n  # quantiles (from Meins)\n\n  for (qc in 1:length(quantiles)){\n    larg <- cumweights<quantiles[qc]\n    wc <- apply(larg,2,sum)+1\n    ind1 <- which(wc<1.1)\n    indn1 <- which(wc>1.1)\n    quant[ind1,qc] <- rep(origObs[1],length(ind1))\n    quantmax <- origObs[wc[indn1]]\n    quantmin <- origObs[wc[indn1]-1]\n    weightmax <- cumweights[cbind(wc[indn1],indn1)]\n    weightmin <- cumweights[cbind(wc[indn1]-1,indn1)]\n    factor <- numeric(length(indn1))\n    indz <- weightmax-weightmin<10^(-10)\n    factor[indz] <- 0.5\n    factor[!indz] <- (quantiles[qc]-weightmin[!indz])/(weightmax[!indz]-weightmin[!indz])\n    quant[indn1,qc] <- quantmin + factor* (quantmax-quantmin)\n  }\n\n  colnames(quant) <- paste(\"quantile=\",quantiles)\n\n  # mediane estimation\n\n  larg <- cumweights< 0.5\n  wc <- apply(larg,2,sum)+1\n  ind1 <- which(wc<1.1)\n  indn1 <- which(wc>1.1)\n  mediane[ind1,1] <- rep(origObs[1],length(ind1))\n  quantmax <- origObs[wc[indn1]]\n  quantmin <- origObs[wc[indn1]-1]\n  weightmax <- cumweights[cbind(wc[indn1],indn1)]\n  weightmin <- cumweights[cbind(wc[indn1]-1,indn1)]\n  factor <- numeric(length(indn1))\n  indz <- weightmax-weightmin<10^(-10)\n  factor[indz] <- 0.5\n  factor[!indz] <- (0.5-weightmin[!indz])/(weightmax[!indz]-weightmin[!indz])\n  mediane[indn1,1] <- quantmin + factor* (quantmax-quantmin)\n\n  tmp <- list(expectation = esperRf, med = mediane, variance = variance, quantiles = quant, weights=weights, weights.std = weights.std, weight=weight, weight.std = weight.std)\n  class(tmp) <- \"regAbcrfpredict\"\n  tmp\n\n}\n\n\nprint.regAbcrfpredict <-\nfunction(x, ...){\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  print(ret, ...)\n\n}\n\nas.data.frame.regAbcrfpredict <-\nfunction(x, ...) {\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  as.data.frame(ret,  row.names=NULL, optional=FALSE, ...)\n\n}\n\nas.matrix.regAbcrfpredict <-\nfunction(x, ...){\n\n  ret <- cbind(x$expectation, x$med, x$variance, x$quantiles)\n  colnames(ret) <- c(\"expectation\", \"median\", \"variance\", colnames(x$quantiles) )\n  ret\n\n}\n\nas.list.regAbcrfpredict <-\nfunction(x, ...){\n\n    list(expectation = x$expectation, med = x$med , variance = x$variance, quantiles=x$quantiles, ...)\n\n}\n",
    "created" : 1479046582619.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2735078613",
    "id" : "7B477090",
    "lastKnownWriteTime" : 1479844916,
    "path" : "F:/These/abcrf_sauvegarde_21_11_2016/R/predict.regAbcrf.R",
    "project_path" : "R/predict.regAbcrf.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}