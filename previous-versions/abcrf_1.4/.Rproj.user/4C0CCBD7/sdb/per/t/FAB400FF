{
    "contents" : "### !!! Je n'ai pas de type=\"vote\" !!!\n\npredict.abcrf <- function(object, obs, ntree=1000, sampsize=min(1e5, dim(sumsta)[1]), paral=FALSE, ...)\n{\n  modindex <- object$y\n  nmod <- nlevels(modindex)\n  sumsta <- object$sumsta\n\tif (object$lda) nstat <- ncol(sumsta)-(nmod-1) else nstat <- ncol(sumsta)\n  if (is.vector(obs)) obs <- matrix(obs,1,length(obs))\n\tif (is.null(colnames(obs))) {\n\t  colnames(obs) <- colnames(sumsta)[1:nstat]\n    warning(\"Columns of obs have no names\")\n\t}\n  if(sampsize > length(modindex))\n    stop(\"sampsize too large\")\n\told.options <- options(); options(warn=-1)\n\tif (object$lda) {\n\t  model.lda <- lda(sumsta[,1:nstat],modindex)\n\t\tobs <- cbind(obs, predict(model.lda,obs)$x)\n\t}\n\t\n\t# pour indiquer mtry si il n'est pas indiqué dans les ...\n\tm <- names(match.call(expand.dots=TRUE))\n\tif (!\"mtry\" %in% m) \n\t  mtry <- max(1, floor(ncol(sumsta)/3) ) # pour éviter de prendre sqrt(p) avec ranger quand regression\n\t\n\t\n\t#### Je dois calculer ça moi même !\n\tvote <- predict(object$model.rf, newdata=obs, type=\"vote\", norm.votes=FALSE) \n\t\n\t\n\tallocation <- predict(object$model.rf, obs)$predictions ### avec combien de cores ici ???\n\tlocal.error <- as.numeric(object$model.rf$predictions==modindex)\n\t\n\t# construction du dataframe pour ranger\n\tdata.ranger <- data.frame(local.error,sumsta)\n\t\n\t  if (paral==TRUE) {\n    ncores <- max(detectCores()-1,1) \n    error.rf <- ranger(local.error~., data=data.ranger, num.trees = ntree, \n                       sample.fraction=sampsize/length(modindex), num.threads = ncores, mtry=mtry, ...)\n    \n    } else error.rf <- ranger(local.error~., data=data.ranger, num.trees = ntree, \n                              sample.fraction=sampsize/length(modindex), num.threads = 1, mtry=mtry, ...)\n\toptions(old.options)\n\ttmp <- list(allocation=allocation, vote=vote, post.prob=predict(error.rf, obs)$predictions ) ### et ce predict, a nouveau combien de cores ??\n  class(tmp) <- \"abcrfpredict\"\n  tmp\n}\n\nsummary.abcrfpredict <- function(object, ...) {\n  cat(\"Number of affectations per model:\\n\")\n  summary(object$allocation, ...)\n}\n\nprint.abcrfpredict <- function(x, ...) {\n  ret <- cbind(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  print(ret, ...)\n}\n\nas.matrix.abcrfpredict <- function(x, ...) {\n  ret <- cbind(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  ret\n}\n\nas.data.frame.abcrfpredict <- function(x, ...) {\n  ret <- cbind(x$allocation, x$vote, x$post.prob)\n  colnames(ret) <- c(\"selected model\", paste(\"votes model\",1:dim(x$vote)[2],sep=\"\"), \"post.proba\")\n  as.data.frame(ret,  row.names=NULL, optional=FALSE, ...)\n}\n\nas.list.abcrfpredict <- function(x, ...) {\n  list(allocation = x$allocation, vote = x$vote, post.prob = x$post.prob, ...)\n}",
    "created" : 1478872911555.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3816752321",
    "id" : "FAB400FF",
    "lastKnownWriteTime" : 1479053160,
    "path" : "F:/These/abcrf_sauvegarde_21_11_2016/R/predict.abcrf.R",
    "project_path" : "R/predict.abcrf.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}