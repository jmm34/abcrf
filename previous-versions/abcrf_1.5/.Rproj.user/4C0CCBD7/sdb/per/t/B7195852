{
    "contents" : "abcrf.factor <- function(modindex, sumsta, lda=TRUE, ntree=500, sampsize=min(1e5, length(modindex)), paral=FALSE, ...) \n{\n\tif (!is.factor(modindex)) \n    stop(\"modindex should be a factor containing the model indexes\")\n  sumsta <- as.matrix(sumsta)\n\tif (length(modindex)!=nrow(sumsta)) \n    stop(\"length of modindex differs from the number of lines in sumsta\")\n  if (length(modindex) == 0L)\n    stop(\"no simulation in the reference table (modindex, sumstat)\")\n  if ( (!is.logical(lda)) && (length(lda) != 1L))\n    stop(\"lda should be TRUE or FALSE\")\n  if (is.null(colnames(sumsta))) colnames(sumsta) <- paste(\"V\",1:dim(sumsta)[2],sep=\"\")\n  if (lda) {\n  \tmodel.lda <- lda(sumsta, modindex)\n    sumsta <- cbind(sumsta, predict(model.lda)$x)\n  } else { \n    model.lda <- NULL\n  }\n  m <- names(match.call(expand.dots=TRUE))\n  if ((!\"sampsize\" %in% m) && (nrow(sumsta) <= 15)) \n    sampsize <- as.integer(sampsize / 10)\n  if(sampsize > length(modindex))\n    stop(\"sampsize too large\")\n  \n  # construction du dataframe pour ranger\n  data.ranger <- data.frame(modindex,sumsta)\n  \n  if(paral==TRUE){\n    ncores <- max(detectCores()-1,1) #### !!! Est ce que nous demandons à l'utilisateur le nombre de core ?\n    model.rf <- ranger(modindex~., data=data.ranger, num.trees=ntree, sample.fraction=sampsize/length(modindex), \n                       num.threads = ncores, keep.inbag = TRUE, importance = 'impurity', ...)\n  }\n  else {\n    model.rf <- ranger(modindex~., data=data.ranger, num.trees=ntree, sample.fraction=sampsize/length(modindex), \n                       num.threads = 1, keep.inbag = TRUE, importance = 'impurity', ...)\n  }\n  # calcul de l'erreur dans chaque classe et on l'ajoute à la table de confusion\n  class.error = vector()\n  \n  for (i in 1:nrow(model.rf$confusion.matrix)) {\n    rowSum <- sum(model.rf$confusion.matrix[i,])\n    accurate <- diag(model.rf$confusion.matrix)[i]\n    error <- rowSum - accurate\n    class.error[i] <- error / rowSum\n  }\n  model.rf$confusion.matrix <- cbind(model.rf$confusion.matrix, class.error)\n  colnames(model.rf$confusion.matrix) <- c(paste(1:nlevels(modindex)),\"class.error\")\n  \n  cl <- match.call()\n  cl[[1]] <- as.name(\"abcrf\")\n  # Je rajoute le y qui n'est pas sauvegardé par la ranger.forest\n  x <- list(call=cl, lda=lda, model.rf=model.rf, model.lda=model.lda, prior.err=model.rf$prediction.error, sumsta=sumsta, y = modindex)\n  class(x) <- \"abcrf\"\n  x\n}\n\nabcrf.formula <- function(formula, data=NULL, ...) {\n  if (!inherits(formula, \"formula\"))\n    stop(\"abcrf.formula is only for formula objects\")\n  m <- match.call(expand.dots=FALSE)\n  names(m)[2] <- \"formula\"\n  m[[1]] <- as.name(\"model.frame\")\n  m <- eval(m, parent.frame())\n  modindex <- model.response(m)\n  Terms <- attr(m, \"terms\")\n  attr(Terms, \"intercept\") <- 0\n  sumsta <- model.frame(terms(reformulate(attributes(Terms)$term.labels)), \n                         data.frame(m))\n  ret <- abcrf(modindex, sumsta, ...)\n  cl <- match.call()\n  cl[[1]] <- as.name(\"abcrf\")\n  ret$call <- cl\n  class(ret) <- c(\"abcrf.formula\", \"abcrf\")\n  return(ret)\n}\n\nabcrf.default <- function(...) {\n  cl <- match.call()\n  cl[[1]] <- as.name(\"abcrf\")\n  cat(\"call:\\n\")\n  print(cl)\n  stop(\"the first argument should be a formula or a factor\")\n}\n  \nabcrf <- function(...) UseMethod(\"abcrf\")\n\nprint.abcrf <- function(x, ...) {\n  cat(\"\\nCall:\\n\", deparse(x$call), \"\\n\")\n  if (x$lda) cat(\"includes the axes of a preliminary LDA\\n\\n\")  \n  cat(\"Number of simulations: \", length(x$model.rf$num.samples), \"\\n\", sep=\"\")\n  cat(\"     Prior error rate: \", round(x$prior.err * 100, digits = 4), \"%\\n\\n\", sep = \"\")\n  cat(\"Confusion matrix:\\n\")\n  print(x$model.rf$confusion, ...)  \n}\n",
    "created" : 1478872828186.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3126295212",
    "id" : "B7195852",
    "lastKnownWriteTime" : 1478772500,
    "path" : "F:/These/abcrf_sauvegarde_21_11_2016/R/abcrf.R",
    "project_path" : "R/abcrf.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}